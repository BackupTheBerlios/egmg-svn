/** \file MSV2D4.h
 * \author <a href="mailto:mail@jirikraus.de">Jiri Kraus</a>
 * \brief Contains the class MSV2D4
 */
#ifndef MSV2D4_H_
#define MSV2D4_H_

#include "Stencil.h"
#include "../Prolongation/Prolongation.h"
#include "../Restriction/Restriction.h"

namespace mg
{

/**
 * \brief   MSV2D4 represents a discrete laplace like operator of second
 *          order.
 * 
 * MSV2D4 is the stencil representing the discrete differential operator
 * \f[
 *  L_h u_h := a_x(u_h)_{xx}+a_y(u_h)_{yy}
 * \f]
 */
class MSV2D4 : public Stencil
{
private:
    mutable NumericArray l_;
    const PositionArray jx_;
    const PositionArray jy_;
    const Precision ax_;
    const Precision ay_;

    //initilize jx_, makes it possible to make jx_ const
    PositionArray initJx_() const
    {
        const int t[]={0,-1,0,1,0,-1,1,-1,1};
        return PositionArray(t,9);
    }

    //initilize jy_, makes it possible to make jy_ const
    PositionArray initJy_() const
    {
        const int t[]={0,0,1,0,-1,-1,-1,1,1};
        return PositionArray(t,9);
    }

    //we don't want the autogenerated copy constructor and assignment operator
    MSV2D4(const MSV2D4&);
    MSV2D4& operator=(const MSV2D4&);
public:
    /**
     * \brief The constructor of a MSV2D4 object
     * 
     * MSV2D4 constructs a MSV2D4 where \f$a_x\f$ and \f$a_y\f$
     * are given by:
     * \param[in] ax   coefficient of the diff. operator (default 1.0)
     * \param[in] ay   coefficient of the diff. operator (default 1.0)
     */
    explicit MSV2D4(Precision ax =1.0,Precision ay =1.0) 
        : l_(9), jx_(initJx_()), jy_(initJy_()), ax_(ax), ay_(ay)
    {}

    virtual ~MSV2D4() {}

    inline Precision apply(
        const NumericArray& u,
        const Position,
        const Index sx,
        const Index sy,
        const Index nx,
        const Index ny) const
    {
        return 
             ((20.0*nx*nx+20.0*ny*ny)/12.0)*u[sy*(nx+1)+sx]
            -10.0*nx*nx/12.0*u[sy*(nx+1)+sx-1]
            -10.0*nx*nx/12.0*u[sy*(nx+1)+sx+1]
            -10.0*ny*ny/12.0*u[sy*(nx+1)+sx-(nx+1)]
            -10.0*ny*ny/12.0*u[sy*(nx+1)+sx+(nx+1)]
            +2.0*nx*nx/12.0*u[sy*(nx+1)+sx-(nx+1)]
            +2.0*nx*nx/12.0*u[sy*(nx+1)+sx+(nx+1)]
            +2.0*ny*ny/12.0*u[sy*(nx+1)+sx-1]
            +2.0*ny*ny/12.0*u[sy*(nx+1)+sx+1]
            -1.0*nx*nx/12.0*
                ( u[sy*(nx+1)+sx-(nx+1)-1]+u[sy*(nx+1)+sx-(nx+1)+1]
                 +u[sy*(nx+1)+sx+(nx+1)-1]+u[sy*(nx+1)+sx+(nx+1)+1])
            -1.0*ny*ny/12.0*
                ( u[sy*(nx+1)+sx-(nx+1)-1]+u[sy*(nx+1)+sx-(nx+1)+1]
                 +u[sy*(nx+1)+sx+(nx+1)-1]+u[sy*(nx+1)+sx+(nx+1)+1]);
    }

    inline Precision getCenter(
        const Position,
        const Index,
        const Index,
        const Index nx,
        const Index ny) const
    {
        return (20.0*nx*nx+20.0*ny*ny)/12.0;
    }

    inline const NumericArray& getL(
        const Position,
        const Index,
        const Index,
        const Index nx,
        const Index ny) const
    {
        l_[0]=20.0*nx*nx/12+20.0*ny*ny/12;
        l_[1]=l_[3]=-10.0*nx*nx/12+2.0*ny*ny/12;
        l_[2]=l_[4]=-10.0*ny*ny/12+2.0*nx*nx/12;
        l_[5]=l_[6]=l_[7]=l_[8]=-1.0*nx*nx/12-1.0*ny*ny/12;
        return l_;
    }

    inline const PositionArray& getJx(const Position) const
    {
        return jx_;
    }

    inline const PositionArray& getJy(const Position) const
    {
        return jy_;
    }

    /**
     * \brief gives the max expansion of MSV2D4
     * 
     * \return  1
     */
    inline Index size() const
    {
        return 1;
    }

    /**
     * \brief returns true, because MSV2D4 is constant
     * 
     * \return  true
     */
    inline bool isConstant() const
    {
        return true;
    }
};

}

#endif /*LAPLACIAN2D2_H_*/
