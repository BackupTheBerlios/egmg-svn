/** \file ConDiff2Dkap.h
 * \author Andrï¿½ Oeckerath
 * \brief Contains the class ConDiff2Dkap
 */
#ifndef ConDiff2Dkap_H_
#define ConDiff2Dkap_H_

#include<vector>
#include<cmath>
#include "Stencil.h"
#include "../Prolongation/Prolongation.h"
#include "../Restriction/Restriction.h"

namespace mg
{

/**
 * \brief 	ConDiff2Dkap represents a discrete convection-diffusion operator of 2nd
 * 			or 3rd order (depending on kappa).
 * 
 * ConDiff2Dkap is the stencil representing the discrete differential operator
 * \f[
 *	L_h u_h := \epsilon(-(u_h)_{xx}-(u_h)_{yy})+ cos(\beta) u_x + sin(\beta) u_y
 * \f]
 */
class ConDiff2Dkap : public mg::Stencil
{
private:
	mutable std::valarray<precision> L_c;
	mutable std::valarray<precision> L_boarder;
	mutable std::valarray<precision> L_corner;
	const std::vector<std::valarray<int> > J_x;
	const std::vector<std::valarray<int> > J_y;
	const precision epsilon;
	const precision beta;
	const precision kappa;
	precision a1;
	precision a2;
	precision factor;
	
	std::vector<std::valarray<int> > init_J_x()
	{
		std::vector<std::valarray<int> > Jx(9);
		const int j_x_c[] = {0,-1,0,1,0,-2,0,2,0};
		Jx[c].resize(9);
		Jx[c] = std::valarray<int>(j_x_c,9);
		int j_x_boarder[] = {0,-1,0,1,0,0,2,0};
		Jx[w].resize(8);
		Jx[w] = std::valarray<int>(j_x_boarder,8);
		j_x_boarder[5]=-2;
		j_x_boarder[6]=2;
		j_x_boarder[7]=0;
		Jx[n].resize(8);
		Jx[n] = std::valarray<int>(j_x_boarder,8);
		j_x_boarder[5]=-2;
		j_x_boarder[6]=0;
		j_x_boarder[7]=0;
		Jx[e].resize(8);
		Jx[e] = std::valarray<int>(j_x_boarder,8);
		j_x_boarder[5]=-2;
		j_x_boarder[6]=0;
		j_x_boarder[7]=2;
		Jx[s].resize(8);
		Jx[s] = std::valarray<int>(j_x_boarder,8);
		int j_x_corner[] = {0,-1,0,1,0,2,0};
		Jx[nw].resize(7);
		Jx[nw] = std::valarray<int>(j_x_corner,7);
		j_x_corner[5]=-2;
		j_x_corner[6]=0;
		Jx[ne].resize(7);
		Jx[ne] = std::valarray<int>(j_x_corner,7);
		j_x_corner[5]=-2;
		j_x_corner[6]=0;
		Jx[se].resize(7);
		Jx[se] = std::valarray<int>(j_x_corner,7);
		j_x_corner[5]=0;
		j_x_corner[6]=2;
		Jx[sw].resize(7);
		Jx[sw] = std::valarray<int>(j_x_corner,7);
		return Jx;
	}
	std::vector<std::valarray<int> > init_J_y()
	{
		std::vector<std::valarray<int> > Jy(9);
		const int j_y_c[] = {0,0,1,0,-1,0,2,0,-2};
		Jy[c].resize(9);
		Jy[c] = std::valarray<int>(j_y_c,9);
		int j_y_boarder[] = {0,0,1,0,-1,2,0,-2};
		Jy[w].resize(8);
		Jy[w] = std::valarray<int>(j_y_boarder,8);
		j_y_boarder[5]=j_y_boarder[6]=0;
		j_y_boarder[7]=-2;
		Jy[n].resize(8);
		Jy[n] = std::valarray<int>(j_y_boarder,8);
		j_y_boarder[5]=0;
		j_y_boarder[6]=2;
		j_y_boarder[7]=-2;
		Jy[e].resize(8);
		Jy[e] = std::valarray<int>(j_y_boarder,8);
		j_y_boarder[5]=0;
		j_y_boarder[6]=2;
		j_y_boarder[7]=0;
		Jy[s].resize(8);
		Jy[s] = std::valarray<int>(j_y_boarder,8);
		int j_y_corner[] = {0,0,1,0,-1,0,-2};
		Jy[nw].resize(7);
		Jy[nw] = std::valarray<int>(j_y_corner,7);
		j_y_corner[5]=0;
		j_y_corner[6]=-2;
		Jy[ne].resize(7);
		Jy[ne] = std::valarray<int>(j_y_corner,7);
		j_y_corner[5]=0;
		j_y_corner[6]=2;
		Jy[se].resize(7);
		Jy[se] = std::valarray<int>(j_y_corner,7);
		j_y_corner[5]=2;
		j_y_corner[6]=0;
		Jy[sw].resize(7);
		Jy[sw] = std::valarray<int>(j_y_corner,7);
		return Jy;
	}
	//initilize a1 and a2
	precision init_coeff(precision beta_) 
	{
		a1 = cos(beta_);
		a2 = sin(beta_);
		return beta_;
	}
    //initilize factor because it is used very often
	precision init_factor(precision kappa_) 
	{
		factor = (1.0 - kappa_)/8;
		return kappa_;
	}
	//we don't want these autogenerated contors and operators
	ConDiff2Dkap(const ConDiff2Dkap& rhs);
	ConDiff2Dkap& operator=(const ConDiff2Dkap& rhs);
public:
	/**
	 * \brief The constructor of a ConDiff2Dkap object
	 * 
	 * ConDiff2Dkap constructs a ConDiff2Dkap where \f$a_x\f$ and \f$a_y\f$
	 * are given by:
	 * \param[in] a_x	coefficient of the diff. operator (default 1.0)
	 * \param[in] a_y	coefficient of the diff. operator (default 1.0)
	 */
	explicit ConDiff2Dkap(precision epsilon_ =1.0, precision beta_ = 0.78539816339745, precision kappa_ = 1.0/3)
			: L_c(9),L_boarder(8),L_corner(7),J_x(init_J_x()),J_y(init_J_y()),
			  epsilon(epsilon_), beta(init_coeff(beta_)), kappa(init_factor(kappa_)) {}
	virtual ~ConDiff2Dkap() {}
	inline precision apply_c(const std::valarray<precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (2.0*epsilon*Nx*Nx+2.0*epsilon*Ny*Ny+factor*(6.0*Nx*fabs(a1)+6.0*Ny*fabs(a2)))*u[j*(Nx+1)+i]
				+factor*Nx*(fabs(a1)+a1)*u[j*(Nx+1)+i-2]
				+(factor*Nx*(-4.0*fabs(a1)-2.0*a1)-epsilon*Nx*Nx)*u[j*(Nx+1)+i-1]
				+(factor*Nx*(-4.0*fabs(a1)+2.0*a1)-epsilon*Nx*Nx)*u[j*(Nx+1)+i+1]
				+factor*Nx*(fabs(a1)-a1)*u[j*(Nx+1)+i+2]
				+factor*Ny*(fabs(a2)+a2)*u[(j-2)*(Nx+1)+i]
				+(factor*Ny*(-4.0*fabs(a2)-2.0*a2)-epsilon*Ny*Ny)*u[(j-1)*(Nx+1)+i]
				+(factor*Ny*(-4.0*fabs(a2)+2.0*a2)-epsilon*Ny*Ny)*u[(j+1)*(Nx+1)+i]
				+factor*Ny*(fabs(a2)-a2)*u[(j+2)*(Nx+1)+i];
	}
	inline precision get_center_c(const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		return (2.0*epsilon*Nx*Nx+2.0*epsilon*Ny*Ny+factor*(6.0*Nx*fabs(a1)+6.0*Ny*fabs(a2)));
	}
	inline precision apply_w(const std::valarray<precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (2.0*epsilon*Nx*Nx+2.0*epsilon*Ny*Ny)*u[j*(Nx+1)+i]
				+(-1.0*epsilon*Nx*Nx-a1*Nx/2)*u[j*(Nx+1)+i-1]
				+(-1.0*epsilon*Nx*Nx+a1*Nx/2)*u[j*(Nx+1)+i+1]
				+(-1.0*epsilon*Ny*Ny-a2*Ny/2)*u[(j-1)*(Nx+1)+i]
				+(-1.0*epsilon*Ny*Ny+a2*Ny/2)*u[(j+1)*(Nx+1)+i];

	}
	inline precision get_center_w(const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		return (2.0*epsilon*Nx*Nx+2.0*epsilon*Ny*Ny);
	}
	inline precision apply_nw(const std::valarray<precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline precision apply_n(const std::valarray<precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline precision apply_ne(const std::valarray<precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline precision apply_e(const std::valarray<precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline precision apply_se(const std::valarray<precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline precision apply_s(const std::valarray<precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline precision apply_sw(const std::valarray<precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline precision get_center_nw(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline precision get_center_n(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline precision get_center_ne(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline precision get_center_e(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline precision get_center_se(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline precision get_center_s(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline precision get_center_sw(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	/**
	 * \brief retruns the coefficents of ConDiff2Dkap for a center point.
	 * 
	 * get_L_c() returns the coefficients of ConDiff2Dkap as valarray. For the
	 * ordering of the elements
	 * \see Stencil
	 * E.g. ConDiv2D4 with the stepsize hx=hy=1, a_1=a_2=1.0 at a center point
	 * looks like:
	 * e = epsilon
	 * L	= {4e + (1-k)/3, -3(1-k)/4 -e, -(1-k)/4 - e, -(1-k)/4 -e, -3(1-k)/4 -e, (1-k)/4, 0, 0, (1-k)/4}\n
	 * J_x 	= { 0,-1,0,1,0,-2,0,2,0}\n
	 * J_y 	= { 0,0,1,0,-1,0,2,0,-2}\n
	 * \param[in]		the x coordinate of the center element (not used)
	 * \param[in]		the y coordinate of the center element (not used)
	 * \param[in] Nx	the step size in x direction
	 * \param[in] Ny	the step size in y direction
	 * \return			the coefficients of ConDiff2Dkap
	 */
	inline const std::valarray<precision>& get_L_c(
							const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		L_c[0] = 2.0*epsilon*Nx*Nx+2.0*epsilon*Ny*Ny+factor*(6.0*Nx*fabs(a1)+6.0*Ny*fabs(a2));
		L_c[1] = factor*Nx*(-4.0*fabs(a1)-2.0*a1)-epsilon*Nx*Nx;
		L_c[3] = factor*Nx*(-4.0*fabs(a1)+2.0*a1)-epsilon*Nx*Nx;
        L_c[2] = factor*Ny*(-4.0*fabs(a2)+2.0*a2)-epsilon*Ny*Ny;
		L_c[4] = factor*Ny*(-4.0*fabs(a2)-2.0*a2)-epsilon*Ny*Ny;
		L_c[5] = factor*Nx*(fabs(a1)+a1);
		L_c[7] = factor*Nx*(fabs(a1)-a1);
		L_c[6] = factor*Ny*(fabs(a2)-a2);
		L_c[8] = factor*Ny*(fabs(a2)+a2);
		return L_c;
	}
	inline const std::valarray<precision>& get_L_w(
							const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
        L_boarder[0] = 2.0*epsilon*Nx*Nx+2.0*epsilon*Ny*Ny;
		L_boarder[1] = -1.0*epsilon*Nx*Nx-a1*Nx/2;
		L_boarder[3] = -1.0*epsilon*Nx*Nx+a1*Nx/2;
		L_boarder[2] = -1.0*epsilon*Ny*Ny-a2*Ny/2;
		L_boarder[4] = -1.0*epsilon*Ny*Ny+a2*Ny/2;
		L_boarder[5] = L_boarder[6] = L_boarder[7] = 0.0;

		return L_boarder;
	}
	inline const std::valarray<precision>& get_L_nw(
							const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
        L_corner[0] = 2.0*epsilon*Nx*Nx+2.0*epsilon*Ny*Ny;
		L_corner[1] = -1.0*epsilon*Nx*Nx-a1*Nx/2;
		L_corner[3] = -1.0*epsilon*Nx*Nx+a1*Nx/2;
		L_corner[2] = -1.0*epsilon*Ny*Ny-a2*Ny/2;
		L_corner[4] = -1.0*epsilon*Ny*Ny+a2*Ny/2;
		L_corner[5] = L_corner[6] = 0.0;

		return L_corner;
	}
	inline const std::valarray<precision>& get_L_n(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_w(i,j,Nx,Ny);
	}
	inline const std::valarray<precision>& get_L_ne(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_nw(i,j,Nx,Ny);
	}
	inline const std::valarray<precision>& get_L_e(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_w(i,j,Nx,Ny);
	}
	inline const std::valarray<precision>& get_L_se(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_nw(i,j,Nx,Ny);
	}
	inline const std::valarray<precision>& get_L_s(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_w(i,j,Nx,Ny);
	}
	inline const std::valarray<precision>& get_L_sw(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_nw(i,j,Nx,Ny);
	}
	inline const std::valarray<int>& get_J_x(const pos p =c) const
	{
		return J_x[p];
	}
	inline const std::valarray<int>& get_J_y(const pos p =c) const
	{
		return J_y[p];
	}
	/**
	 * \brief does nothing for ConDiff2Dkap
	 * \see Stencil
	 */
	void push_prolongation(const Prolongation&) {}
	/**
	 * \brief does nothing for ConDiff2Dkap
	 * \see Stencil
	 */
	void pop_prolongation() {}
	/**
	 * \brief does nothing for ConDiff2Dkap
	 * \see Stencil
	 */
	void push_restriction(const Restriction&) {}
	/**
	 * \brief does nothing for ConDiff2Dkap
	 * \see Stencil
	 */
	void pop_restriction() {}
	/**
	 * \brief gives the max expansion of ConDiff2Dkap
	 * 
	 * \return	2
	 */
	inline size_t size() const
	{
		return 2;
	}
	/**
	 * \brief returns true, because ConDiff2Dkap is constant
	 * 
	 * \return	true
	 */
	inline bool is_constant() const
	{
		return true;
	}
};

}

#endif /*ConDiff2Dkap_H_*/
