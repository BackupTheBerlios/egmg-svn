/** \file Laplacian2D4.h
 * \author <a href="mailto:mail@jirikraus.de">Jiri Kraus</a>
 * \brief Contains the class Laplacian2D4
 */
#ifndef LAPLACIAN2D4_H_
#define LAPLACIAN2D4_H_

#include <vector>
#include <valarray>
#include "Stencil.h"
#include "../Prolongation/Prolongation.h"
#include "../Restriction/Restriction.h"

namespace mg
{

/**
 * \brief   Laplacian2D4 represents a discrete laplace like operator of fourth
 *          order.
 * 
 * Laplacian2D4 is the stencil representing the discrete differential operator
 * \f[
 *  L_hu_h := a_x(u_h)_{xx}+a_y(u_h)_{yy}
 * \f]
 */
class Laplacian2D4 : public Stencil
{
private:
    mutable std::valarray<Precision> lCenter_;
    mutable std::valarray<Precision> lBorder_;
    mutable std::valarray<Precision> lCorner_;
    const std::vector<std::valarray<int> > jx_;
    const std::vector<std::valarray<int> > jy_;
    const Precision ax_;
    const Precision ay_;

    std::vector<std::valarray<int> > initJx_()
    {
        std::vector<std::valarray<int> > jx(9);

        const int jxCenter[]={0,-1,0,1,0,-2,0,2,0};

        jx[C].resize(9);
        jx[C]=std::valarray<int>(jxCenter,9);

        int jxBorder[]={0,-1,0,1,0,0,2,0};

        jx[W].resize(8);
        jx[W]=std::valarray<int>(jxBorder,8);

        jxBorder[5]=-2;
        jxBorder[6]=2;
        jxBorder[7]=0;
        jx[N].resize(8);
        jx[N]=std::valarray<int>(jxBorder,8);

        jxBorder[5]=-2;
        jxBorder[6]=0;
        jxBorder[7]=0;
        jx[E].resize(8);
        jx[E]=std::valarray<int>(jxBorder,8);

        jxBorder[5]=-2;
        jxBorder[6]=0;
        jxBorder[7]=2;
        jx[S].resize(8);
        jx[S]=std::valarray<int>(jxBorder,8);

        int jxCorner[]={0,-1,0,1,0,2,0};

        jx[NW].resize(7);
        jx[NW]=std::valarray<int>(jxCorner,7);

        jxCorner[5]=-2;
        jxCorner[6]=0;
        jx[NE].resize(7);
        jx[NE]=std::valarray<int>(jxCorner,7);

        jxCorner[5]=-2;
        jxCorner[6]=0;
        jx[SE].resize(7);
        jx[SE]=std::valarray<int>(jxCorner,7);

        jxCorner[5]=0;
        jxCorner[6]=2;
        jx[SW].resize(7);
        jx[SW]=std::valarray<int>(jxCorner,7);

        return jx;
    }

    std::vector<std::valarray<int> > initJy_()
    {
        std::vector<std::valarray<int> > jy(9);

        const int jyCenter[]={0,0,1,0,-1,0,2,0,-2};

        jy[C].resize(9);
        jy[C]=std::valarray<int>(jyCenter,9);

        int jyBorder[]={0,0,1,0,-1,2,0,-2};

        jy[W].resize(8);
        jy[W]=std::valarray<int>(jyBorder,8);

        jyBorder[5]=jyBorder[6]=0;
        jyBorder[7]=-2;
        jy[N].resize(8);
        jy[N]=std::valarray<int>(jyBorder,8);

        jyBorder[5]=0;
        jyBorder[6]=2;
        jyBorder[7]=-2;
        jy[E].resize(8);
        jy[E]=std::valarray<int>(jyBorder,8);

        jyBorder[5]=0;
        jyBorder[6]=2;
        jyBorder[7]=0;
        jy[S].resize(8);
        jy[S]=std::valarray<int>(jyBorder,8);

        int jyCorner[]={0,0,1,0,-1,0,-2};

        jy[NW].resize(7);
        jy[NW]=std::valarray<int>(jyCorner,7);

        jyCorner[5]=0;
        jyCorner[6]=-2;
        jy[NE].resize(7);
        jy[NE]=std::valarray<int>(jyCorner,7);

        jyCorner[5]=0;
        jyCorner[6]=2;
        jy[SE].resize(7);
        jy[SE]=std::valarray<int>(jyCorner,7);

        jyCorner[5]=2;
        jyCorner[6]=0;
        jy[SW].resize(7);
        jy[SW]=std::valarray<int>(jyCorner,7);

        return jy;
    }

    //we don't want the autogenerated copy constructor and assignment operator
    Laplacian2D4(const Laplacian2D4&);
    Laplacian2D4& operator=(const Laplacian2D4&);
public:
    /**
     * \brief The constructor of a Laplacian2D4 object
     * 
     * Laplacian2D4 constructs a Laplacian2D4 where \f$a_x\f$ and \f$a_y\f$
     * are given by:
     * \param[in] ax    coefficient of the diff. operator (default 1.0)
     * \param[in] ay    coefficient of the diff. operator (default 1.0)
     */
    explicit Laplacian2D4(Precision ax=1.0,Precision ay=1.0)
            : lCenter_(9), lBorder_(8), lCorner_(7),
              jx_(initJx_()), jy_(initJy_()),
              ax_(ax), ay_(ay)
    {}

    virtual ~Laplacian2D4() {}

    inline Precision apply(
        const std::valarray<Precision>& u,
        const Position position,
        const size_t sx,
        const size_t sy,
        const size_t nx,
        const size_t ny) const
    {
        switch(position)
        {
        case C:
            return 
                 (30.0*ax_*nx*nx/12.0+30.0*ay_*ny*ny/12.0)*u[sy*(nx+1)+sx]
                +1.0*ax_*nx*nx/12.0*u[sy*(nx+1)+sx-2]
                -16.0*ax_*nx*nx/12.0*u[sy*(nx+1)+sx-1]
                -16.0*ax_*nx*nx/12.0*u[sy*(nx+1)+sx+1]
                +1.0*ax_*nx*nx/12.0*u[sy*(nx+1)+sx+2]
                +1.0*ay_*ny*ny/12.0*u[(sy-2)*(nx+1)+sx]
                -16.0*ay_*ny*ny/12.0*u[(sy-1)*(nx+1)+sx]
                -16.0*ay_*ny*ny/12.0*u[(sy+1)*(nx+1)+sx]
                +1.0*ay_*ny*ny/12.0*u[(sy+2)*(nx+1)+sx];
        default:
            return 
                 (2.0*ax_*nx*nx+2.0*ay_*ny*ny)*u[sy*(nx+1)+sx]
                -1.0*ax_*nx*nx*u[sy*(nx+1)+sx-1]
                -1.0*ax_*nx*nx*u[sy*(nx+1)+sx+1]
                -1.0*ay_*ny*ny*u[(sy-1)*(nx+1)+sx]
                -1.0*ay_*ny*ny*u[(sy+1)*(nx+1)+sx];
        }
    }

    inline Precision getCenter(
        const Position position,
        const size_t,
        const size_t,
        const size_t nx,
        const size_t ny) const
    {

        switch(position)
        {
        case C:
            return 30.0*ax_*nx*nx/12.0+30.0*ay_*ny*ny/12.0;
        default:
            return 2.0*ax_*nx*nx+2.0*ay_*ny*ny;
        }
    }

    /**
     * \brief retruns the coefficents of Laplacian2D4 for a center point.
     * 
     * getL() returns the coefficients of Laplacian2D4 as valarray. For the
     * ordering of the elements
     * \see Stencil
     * E.g. Laplacian2D4 with the stepsize hx=hy=1, a_x=a_y=1.0 at a center point
     * looks like:
     * \f[
     * \frac{1}{12}
     * \left[\begin{array}{ccccc}
     *  &   &       1   &   &   \\
     *  &   &       -16 &   &   \\
     * 1&   -16&    60& -16&    1\\
     *  &   &       -16 &   &   \\
     * &    &       1   &   &   \\
     * \end{array}\right]
     * \f]
     * So we have:\n
     * L    = {60/12,-16/12,-16/12,-16/12,-16/12, 1/12, 1/12,1/12, 1/12}\n
     * J_x  = { 0,-1,0,1,0,-2,0,2,0}\n
     * J_y  = { 0,0,1,0,-1,0,2,0,-2}\n
     * 
     * \param[in]       the x coordinate of the center element (not used)
     * \param[in]       the y coordinate of the center element (not used)
     * \param[in] nx    the step size in x direction
     * \param[in] ny    the step size in y direction
     * \return          the coefficients of Laplacian2D4
     */
    inline const std::valarray<Precision>& getL(
        const Position position,
        const size_t,
        const size_t,
        const size_t nx,
        const size_t ny) const
    {
        switch (position)
        {
        case C:
            lCenter_[0] =30.0*ax_*nx*nx/12.0+30.0*ay_*ny*ny/12.0;
            lCenter_[1]=lCenter_[3]=-16.0*ax_*nx*nx/12.0;
            lCenter_[5]=lCenter_[7]=+1.0*ax_*nx*nx/12.0;
            lCenter_[2]=lCenter_[4]=-16.0*ay_*ny*ny/12.0;
            lCenter_[6]=lCenter_[8]=+1.0*ay_*ny*ny/12.0;
            return lCenter_;
        case N:
        case E:
        case S:
        case W:
            lBorder_[0]=2.0*ax_*nx*nx+2.0*ay_*ny*ny;
            lBorder_[1]=lBorder_[3]=-1.0*ax_*nx*nx;
            lBorder_[2]=lBorder_[4]=-1.0*ay_*ny*ny;
            lBorder_[5]=lBorder_[6]=lBorder_[7]=0.0;
            return lBorder_;
        case NW:
        case NE:
        case SE:
        case SW:
            lCorner_[0]=2.0*ax_*nx*nx+2.0*ay_*ny*ny;
            lCorner_[1]=lCorner_[3]=-1.0*ax_*nx*nx;
            lCorner_[2]=lCorner_[4]=-1.0*ay_*ny*ny;
            lCorner_[5]=lCorner_[6]=0.0;
            return lCorner_;
        }
        return lCenter_; //never reached
    }

    inline const std::valarray<int>& getJx(const Position position) const
    {
        return jx_[position];

    }

    inline const std::valarray<int>& getJy(const Position position) const
    {
        return jy_[position];
    }

    /**
     * \brief does nothing for Laplacian2D4
     * \see Stencil
     */
    void pushProlongation(const Prolongation&) {}

    /**
     * \brief does nothing for Laplacian2D4
     * \see Stencil
     */
    void popProlongation() {}

    /**
     * \brief does nothing for Laplacian2D4
     * \see Stencil
     */
    void pushRestriction(const Restriction&) {}

    /**
     * \brief does nothing for Laplacian2D4
     * \see Stencil
     */
    void popRestriction() {}

    /**
     * \brief gives the max expansion of Laplacian2D4
     * 
     * \return  2
     */
    inline size_t size() const
    {
        return 2;
    }

    /**
     * \brief returns true, because Laplacian2D4 is constant
     * 
     * \return  true
     */
    inline bool isConstant() const
    {
        return true;
    }
};

}

#endif /*LAPLACIAN2D4_H_*/
