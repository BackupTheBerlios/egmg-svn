/** \file Laplacian2D4.h
 * \author <a href="mailto:mail@jirikraus.de">Jiri Kraus</a>
 * \brief Contains the class Laplacian2D4
 */
#ifndef LAPLACIAN2D4_H_
#define LAPLACIAN2D4_H_

#include<vector>
#include "Stencil.h"
#include "../Prolongation/Prolongation.h"
#include "../Restriction/Restriction.h"

namespace mg
{

/**
 * \brief 	Laplacian2D4 represents a discrete laplace like operator of fourth
 * 			order.
 * 
 * Laplacian2D4 is the stencil representing the discrete differential operator
 * \f[
 *	L_hu_h := a_x(u_h)_{xx}+a_y(u_h)_{yy}
 * \f]
 */
class Laplacian2D4 : public mg::Stencil
{
private:
	mutable std::valarray<Precision> L_c;
	mutable std::valarray<Precision> L_boarder;
	mutable std::valarray<Precision> L_corner;
	const std::vector<std::valarray<int> > J_x;
	const std::vector<std::valarray<int> > J_y;
	const Precision ax;
	const Precision ay;
	std::vector<std::valarray<int> > init_J_x()
	{
		std::vector<std::valarray<int> > Jx(9);
		const int j_x_c[] = {0,-1,0,1,0,-2,0,2,0};
		Jx[c].resize(9);
		Jx[c] = std::valarray<int>(j_x_c,9);
		int j_x_boarder[] = {0,-1,0,1,0,0,2,0};
		Jx[w].resize(8);
		Jx[w] = std::valarray<int>(j_x_boarder,8);
		j_x_boarder[5]=-2;
		j_x_boarder[6]=2;
		j_x_boarder[7]=0;
		Jx[n].resize(8);
		Jx[n] = std::valarray<int>(j_x_boarder,8);
		j_x_boarder[5]=-2;
		j_x_boarder[6]=0;
		j_x_boarder[7]=0;
		Jx[e].resize(8);
		Jx[e] = std::valarray<int>(j_x_boarder,8);
		j_x_boarder[5]=-2;
		j_x_boarder[6]=0;
		j_x_boarder[7]=2;
		Jx[s].resize(8);
		Jx[s] = std::valarray<int>(j_x_boarder,8);
		int j_x_corner[] = {0,-1,0,1,0,2,0};
		Jx[nw].resize(7);
		Jx[nw] = std::valarray<int>(j_x_corner,7);
		j_x_corner[5]=-2;
		j_x_corner[6]=0;
		Jx[ne].resize(7);
		Jx[ne] = std::valarray<int>(j_x_corner,7);
		j_x_corner[5]=-2;
		j_x_corner[6]=0;
		Jx[se].resize(7);
		Jx[se] = std::valarray<int>(j_x_corner,7);
		j_x_corner[5]=0;
		j_x_corner[6]=2;
		Jx[sw].resize(7);
		Jx[sw] = std::valarray<int>(j_x_corner,7);
		return Jx;
	}
	std::vector<std::valarray<int> > init_J_y()
	{
		std::vector<std::valarray<int> > Jy(9);
		const int j_y_c[] = {0,0,1,0,-1,0,2,0,-2};
		Jy[c].resize(9);
		Jy[c] = std::valarray<int>(j_y_c,9);
		int j_y_boarder[] = {0,0,1,0,-1,2,0,-2};
		Jy[w].resize(8);
		Jy[w] = std::valarray<int>(j_y_boarder,8);
		j_y_boarder[5]=j_y_boarder[6]=0;
		j_y_boarder[7]=-2;
		Jy[n].resize(8);
		Jy[n] = std::valarray<int>(j_y_boarder,8);
		j_y_boarder[5]=0;
		j_y_boarder[6]=2;
		j_y_boarder[7]=-2;
		Jy[e].resize(8);
		Jy[e] = std::valarray<int>(j_y_boarder,8);
		j_y_boarder[5]=0;
		j_y_boarder[6]=2;
		j_y_boarder[7]=0;
		Jy[s].resize(8);
		Jy[s] = std::valarray<int>(j_y_boarder,8);
		int j_y_corner[] = {0,0,1,0,-1,0,-2};
		Jy[nw].resize(7);
		Jy[nw] = std::valarray<int>(j_y_corner,7);
		j_y_corner[5]=0;
		j_y_corner[6]=-2;
		Jy[ne].resize(7);
		Jy[ne] = std::valarray<int>(j_y_corner,7);
		j_y_corner[5]=0;
		j_y_corner[6]=2;
		Jy[se].resize(7);
		Jy[se] = std::valarray<int>(j_y_corner,7);
		j_y_corner[5]=2;
		j_y_corner[6]=0;
		Jy[sw].resize(7);
		Jy[sw] = std::valarray<int>(j_y_corner,7);
		return Jy;
	}
	//we don't want these autogenerated contors and operators
	Laplacian2D4(const Laplacian2D4& rhs);
	Laplacian2D4& operator=(const Laplacian2D4& rhs);
public:
	/**
	 * \brief The constructor of a Laplacian2D4 object
	 * 
	 * Laplacian2D4 constructs a Laplacian2D4 where \f$a_x\f$ and \f$a_y\f$
	 * are given by:
	 * \param[in] a_x	coefficient of the diff. operator (default 1.0)
	 * \param[in] a_y	coefficient of the diff. operator (default 1.0)
	 */
	explicit Laplacian2D4(Precision a_x =1.0,Precision a_y =1.0)
			: L_c(9),L_boarder(8),L_corner(7),J_x(init_J_x()),J_y(init_J_y())
				,ax(a_x),ay(a_y) {}
	virtual ~Laplacian2D4() {}
	inline Precision apply_c(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (30.0*ax*Nx*Nx/12.0+30.0*ay*Ny*Ny/12.0)*u[j*(Nx+1)+i]
				+1.0*ax*Nx*Nx/12.0*u[j*(Nx+1)+i-2]
				-16.0*ax*Nx*Nx/12.0*u[j*(Nx+1)+i-1]
				-16.0*ax*Nx*Nx/12.0*u[j*(Nx+1)+i+1]
				+1.0*ax*Nx*Nx/12.0*u[j*(Nx+1)+i+2]
				+1.0*ay*Ny*Ny/12.0*u[(j-2)*(Nx+1)+i]
				-16.0*ay*Ny*Ny/12.0*u[(j-1)*(Nx+1)+i]
				-16.0*ay*Ny*Ny/12.0*u[(j+1)*(Nx+1)+i]
				+1.0*ay*Ny*Ny/12.0*u[(j+2)*(Nx+1)+i];
	}
	inline Precision get_center_c(const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		return (30.0*ax*Nx*Nx/12.0+30.0*ay*Ny*Ny/12.0);
	}
	inline Precision apply_w(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (2.0*ax*Nx*Nx+2.0*ay*Ny*Ny)*u[j*(Nx+1)+i]
				-1.0*ax*Nx*Nx*u[j*(Nx+1)+i-1]-1.0*ax*Nx*Nx*u[j*(Nx+1)+i+1]
				-1.0*ay*Ny*Ny*u[(j-1)*(Nx+1)+i]-1.0*ay*Ny*Ny*u[(j+1)*(Nx+1)+i];
	}
	inline Precision get_center_w(const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		return (2.0*ax*Nx*Nx+2.0*ay*Ny*Ny);
	}
	inline Precision apply_nw(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline Precision apply_n(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline Precision apply_ne(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline Precision apply_e(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline Precision apply_se(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline Precision apply_s(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline Precision apply_sw(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_w(u,i,j,Nx,Ny);
	}
	inline Precision get_center_nw(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline Precision get_center_n(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline Precision get_center_ne(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline Precision get_center_e(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline Precision get_center_se(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline Precision get_center_s(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	inline Precision get_center_sw(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_w(i,j,Nx,Ny);	
	}
	/**
	 * \brief retruns the coefficents of Laplacian2D4 for a center point.
	 * 
	 * get_L_c() returns the coefficients of Laplacian2D4 as valarray. For the
	 * ordering of the elements
	 * \see Stencil
	 * E.g. Laplacian2D4 with the stepsize hx=hy=1, a_x=a_y=1.0 at a center point
	 * looks like:
	 * \f[
	 * \frac{1}{12}
	 * \left[\begin{array}{ccccc}
	 * 	&	&		1	&	&	\\
	 * 	&	&		-16	&	&	\\
	 * 1&	-16&	60&	-16&	1\\
	 * 	&	&		-16	&	&	\\
	 * &	&		1	&	&	\\
	 * \end{array}\right]
	 * \f]
	 * So we have:\n
	 * L	= {60/12,-16/12,-16/12,-16/12,-16/12, 1/12, 1/12,1/12, 1/12}\n
	 * J_x 	= { 0,-1,0,1,0,-2,0,2,0}\n
	 * J_y 	= { 0,0,1,0,-1,0,2,0,-2}\n
	 * 
	 * \param[in]		the x coordinate of the center element (not used)
	 * \param[in]		the y coordinate of the center element (not used)
	 * \param[in] Nx	the step size in x direction
	 * \param[in] Ny	the step size in y direction
	 * \return			the coefficients of Laplacian2D4
	 */
	inline const std::valarray<Precision>& get_L_c(
							const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		L_c[0] =30.0*ax*Nx*Nx/12.0+30.0*ay*Ny*Ny/12.0;
		L_c[1] = L_c[3] = -16.0*ax*Nx*Nx/12.0;
		L_c[5] = L_c[7] = +1.0*ax*Nx*Nx/12.0;
		L_c[2] = L_c[4] = -16.0*ay*Ny*Ny/12.0;
		L_c[6] = L_c[8] = +1.0*ay*Ny*Ny/12.0;
		return L_c;
	}
	inline const std::valarray<Precision>& get_L_w(
							const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		L_boarder[0] = 2.0*ax*Nx*Nx+2.0*ay*Ny*Ny;
		L_boarder[1] = L_boarder[3] = -1.0*ax*Nx*Nx;
		L_boarder[2] = L_boarder[4] = -1.0*ay*Ny*Ny;
		L_boarder[5] = L_boarder[6] = L_boarder[7] = 0.0;
		return L_boarder;
	}
	inline const std::valarray<Precision>& get_L_nw(
							const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		L_corner[0] = 2.0*ax*Nx*Nx+2.0*ay*Ny*Ny;
		L_corner[1] = L_corner[3] = -1.0*ax*Nx*Nx;
		L_corner[2] = L_corner[4] = -1.0*ay*Ny*Ny;
		L_corner[5] = L_corner[6] = 0.0;
		return L_corner;
	}
	inline const std::valarray<Precision>& get_L_n(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_w(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_ne(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_nw(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_e(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_w(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_se(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_nw(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_s(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_w(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_sw(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_nw(i,j,Nx,Ny);
	}
	inline const std::valarray<int>& get_J_x(const Position p =c) const
	{
		return J_x[p];
	}
	inline const std::valarray<int>& get_J_y(const Position p =c) const
	{
		return J_y[p];
	}
	/**
	 * \brief does nothing for Laplacian2D4
	 * \see Stencil
	 */
	void push_prolongation(const Prolongation&) {}
	/**
	 * \brief does nothing for Laplacian2D4
	 * \see Stencil
	 */
	void pop_prolongation() {}
	/**
	 * \brief does nothing for Laplacian2D4
	 * \see Stencil
	 */
	void push_restriction(const Restriction&) {}
	/**
	 * \brief does nothing for Laplacian2D4
	 * \see Stencil
	 */
	void pop_restriction() {}
	/**
	 * \brief gives the max expansion of Laplacian2D4
	 * 
	 * \return	2
	 */
	inline size_t size() const
	{
		return 2;
	}
	/**
	 * \brief returns true, because Laplacian2D4 is constant
	 * 
	 * \return	true
	 */
	inline bool is_constant() const
	{
		return true;
	}
};

}

#endif /*LAPLACIAN2D4_H_*/
