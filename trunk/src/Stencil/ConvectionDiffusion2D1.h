/** \file ConvectionDiffusion2D1.h
 * \author Andr� Oeckerath
 * \brief Contains the class ConvectionDiffusion2D1
 */
#ifndef ConvectionDiffusion2D1_H_
#define ConvectionDiffusion2D1_H_

#include <cmath>
#include "Stencil.h"
#include "../Prolongation/Prolongation.h"
#include "../Restriction/Restriction.h"

namespace mg
{

/**
 * \brief 	ConvectionDiffusion2D1 represents a discrete Convection Diffusion operator of first
 * 			order.
 * 
 * ConvectionDiffusion2D1 is the stencil representing the discrete differential operator
 * \f[
 *	L_h u_h := \epsilon (-(u_h)_{xx}-(u_h)_{yy}) + a(x/y) u_x + b(x,y) u_y
 * \f]
 */
class ConvectionDiffusion2D1 : public mg::Stencil
{
private:
	mutable std::valarray<Precision> L;
	const std::valarray<int> J_x;
	const std::valarray<int> J_y;
	const Precision epsilon;
	 int mode;
	
	//initilize J_x, makes it possible to make J_x const
	std::valarray<int> init_J_x() const
	{
		const int t[] = {0,-1,0,1,0};
		return std::valarray<int>(t,5);
	}
	//initilize J_y, makes it possible to make J_y const
	std::valarray<int> init_J_y() const
	{
		const int t[] = {0,0,1,0,-1};
		return std::valarray<int>(t,5);
	}
    
	Precision a(const size_t i, const size_t j, const size_t Nx, const size_t Ny) const
	{
		switch(mode)
		{
		case 0:
			{
				return ( (2.0*j/Ny - 1) * (1 - (i*i)/(Nx*Nx)) );
			}
		case 1:
			{
				return ( 4.0*i/Nx*(i/Nx - 1) * (1 - 2.0*j/Ny) );
			}
		default:
			{

			}
		}
	}
    
	Precision b(const size_t i, const size_t j, const size_t Nx, const size_t Ny) const
	{
		switch(mode)
		{
		case 0:
			{
				return ( (2.0*i*j/(Nx*Ny))* (j/Ny - 1) );
			}
		case 1:
			{
				return ( -4.0*j/Ny*(j/Ny - 1) * (1 - 2.0*i/Nx) );
			}
		default:
			{

			}
		}		
	}
	//we don't want these autogenerated ctors and operators
	ConvectionDiffusion2D1(const ConvectionDiffusion2D1& rhs);
	ConvectionDiffusion2D1& operator=(const ConvectionDiffusion2D1& rhs);
public:
	/**
	 * \brief The constructor of a ConvectionDiffusion2D1 object
	 * 
	 * ConvectionDiffusion2D1 constructs a ConvectionDiffusion2D1 where \f$\epsilon\f$, \f$a_1\f$ and \f$a_2\f$
	 * are given by:
     * \param[in] \epsilon coefficient of the diffusion part (default 1.0)
	 * \param[in] a = (2 x_2 - 1)(1 - x�_1)	coefficient of the convection part (default \pi/4)
	 * \param[in] b = 2 x_1 x_2 (x_2 - 1)	coefficient of the convection part (default \pi/4)
	 */
	explicit ConvectionDiffusion2D1(Precision epsilon_ =1.0, int mode_ = 0) 
		: L(5), J_x(init_J_x()), J_y(init_J_y()), epsilon(epsilon_), mode(mode_) {}
	virtual ~ConvectionDiffusion2D1() {}
	inline Precision apply_c(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return ( 2.0*epsilon*Nx*Nx+2.0*epsilon*Ny*Ny+fabs(a(i,j,Nx,Ny))*Nx+fabs(b(i,j,Nx,Ny))*Ny )*u[j*(Nx+1)+i]
				+( -1.0*epsilon*Nx*Nx+(-a(i,j,Nx,Ny)-fabs(a(i,j,Nx,Ny)))*Nx/2 )*u[j*(Nx+1)+i-1]
				+( -1.0*epsilon*Nx*Nx+(a(i,j,Nx,Ny)-fabs(a(i,j,Nx,Ny)))*Nx/2 )*u[j*(Nx+1)+i+1]
				+( -1.0*epsilon*Ny*Ny+(-b(i,j,Nx,Ny)-fabs(b(i,j,Nx,Ny)))*Ny/2 )*u[(j-1)*(Nx+1)+i]
				+( -1.0*epsilon*Ny*Ny+(b(i,j,Nx,Ny)-fabs(b(i,j,Nx,Ny)))*Ny/2 )*u[(j+1)*(Nx+1)+i];
	}
	inline Precision get_center_c(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return (2.0*epsilon*Nx*Nx+2.0*epsilon*Ny*Ny+fabs( a(i,j,Nx,Ny) )*Nx+fabs( b(i,j,Nx,Ny) )*Ny);
	}
	inline Precision apply_w(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_c(u,i,j,Nx,Ny);
	}
	inline Precision apply_nw(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_c(u,i,j,Nx,Ny);
	}
	inline Precision apply_n(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_c(u,i,j,Nx,Ny);
	}
	inline Precision apply_ne(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_c(u,i,j,Nx,Ny);
	}
	inline Precision apply_e(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_c(u,i,j,Nx,Ny);
	}
	inline Precision apply_se(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_c(u,i,j,Nx,Ny);
	}
	inline Precision apply_s(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_c(u,i,j,Nx,Ny);
	}
	inline Precision apply_sw(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return apply_c(u,i,j,Nx,Ny);
	}
	inline Precision get_center_w(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_c(i,j,Nx,Ny);
	}
	inline Precision get_center_nw(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_c(i,j,Nx,Ny);
	}
	inline Precision get_center_n(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_c(i,j,Nx,Ny);
	}
	inline Precision get_center_ne(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_c(i,j,Nx,Ny);
	}
	inline Precision get_center_e(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_c(i,j,Nx,Ny);
	}
	inline Precision get_center_se(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_c(i,j,Nx,Ny);
	}
	inline Precision get_center_s(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_c(i,j,Nx,Ny);
	}
	inline Precision get_center_sw(const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_center_c(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_c(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		L[0] = 2.0*epsilon*Nx*Nx+2.0*epsilon*Ny*Ny+fabs(a(i,j,Nx,Ny))*Nx+fabs(b(i,j,Nx,Ny))*Ny;
		L[1] = -1.0*epsilon*Nx*Nx+( -a(i,j,Nx,Ny)-fabs(a(i,j,Nx,Ny)) )*Nx/2;
		L[3] = -1.0*epsilon*Nx*Nx+( a(i,j,Nx,Ny)-fabs(a(i,j,Nx,Ny)) )*Nx/2;
		L[2] = -1.0*epsilon*Ny*Ny+( -b(i,j,Nx,Ny)-fabs(b(i,j,Nx,Ny)) )*Ny/2;
		L[4] = -1.0*epsilon*Ny*Ny+( b(i,j,Nx,Ny)-fabs(b(i,j,Nx,Ny)) )*Ny/2;
		return L; 
	}
	inline const std::valarray<Precision>& get_L_w(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_c(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_nw(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_c(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_n(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_c(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_ne(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_c(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_e(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_c(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_se(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_c(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_s(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_c(i,j,Nx,Ny);
	}
	inline const std::valarray<Precision>& get_L_sw(
							const size_t i, const size_t j,
							const size_t Nx, const size_t Ny) const
	{
		return get_L_c(i,j,Nx,Ny);
	}
	inline const std::valarray<int>& get_J_x(const Position =c) const
	{
		return J_x;
	}
	inline const std::valarray<int>& get_J_y(const Position =c) const
	{
		return J_y;
	}
	/**
	 * \brief does nothing for ConvectionDiffusion2D1
	 * \see Stencil
	 */
	void push_prolongation(const Prolongation&) {}
	/**
	 * \brief does nothing for ConvectionDiffusion2D1
	 * \see Stencil
	 */
	void pop_prolongation() {}
	/**
	 * \brief does nothing for ConvectionDiffusion2D1
	 * \see Stencil
	 */
	void push_restriction(const Restriction&) {}
	/**
	 * \brief does nothing for ConvectionDiffusion2D1
	 * \see Stencil
	 */
	void pop_restriction() {}
	/**
	 * \brief gives the max expansion of ConvectionDiffusion2D1
	 * 
	 * \return	1
	 */
	inline size_t size() const
	{
		return 1;
	}
	/**
	 * \brief returns false, because ConvectionDiffusion2D1 is not constant
	 * 
	 * \return	false
	 */
	inline bool is_constant() const
	{
		return false;
	}
	
};

}

#endif /*ConvectionDiffusion2D1_H_*/
