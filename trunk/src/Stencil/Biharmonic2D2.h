/** \file Biharmonic2D2.h
 * \author André Oeckerath
 * \brief Contains the class Biharmonic2D2
 */
#ifndef Biharmonic2D2_H_
#define Biharmonic2D2_H_

#include<vector>
#include "Stencil.h"
#include "../Prolongation/Prolongation.h"
#include "../Restriction/Restriction.h"

namespace mg
{

/**
 * \brief 	Biharmonic2D2 represents a discrete laplace like operator of fourth
 * 			order.
 * 
 * Biharmonic2D2 is the stencil representing the discrete differential operator
 * \f[
 *	L_hu_h := (\delta_{xx} + \delta_{yy})(\delta_{xx} + \delta_{yy}) u_h
 * \f]
 */
class Biharmonic2D2 : public mg::Stencil
{
private:
	mutable std::valarray<Precision> L_c;
	mutable std::valarray<Precision> L_boarder;
	mutable std::valarray<Precision> L_corner;
	const std::vector<std::valarray<int> > J_x;
	const std::vector<std::valarray<int> > J_y;
	std::vector<std::valarray<int> > init_J_x()
	{
		std::vector<std::valarray<int> > Jx(13);
		const int j_x_c[] = {0,-1,0,1,0,-2,0,2,0,-1,1,1,-1};
		Jx[c].resize(13);
		Jx[c] = std::valarray<int>(j_x_c,13);
		int j_x_boarder[] = {0,-1,0,1,0,0,2,0,-1,1,1,-1};
		Jx[w].resize(12);
		Jx[w] = std::valarray<int>(j_x_boarder,12);
		j_x_boarder[5]=-2;
		j_x_boarder[6]=2;
		j_x_boarder[7]=0;
		j_x_boarder[8]=-1;
		j_x_boarder[9]=1;
		j_x_boarder[10]=1;
		j_x_boarder[11]=-1;
		Jx[n].resize(12);
		Jx[n] = std::valarray<int>(j_x_boarder,12);
		j_x_boarder[5]=-2;
		j_x_boarder[6]=0;
		j_x_boarder[7]=0;
		j_x_boarder[8]=-1;
		j_x_boarder[9]=1;
		j_x_boarder[10]=1;
		j_x_boarder[11]=-1;
		Jx[e].resize(12);
		Jx[e] = std::valarray<int>(j_x_boarder,12);
		j_x_boarder[5]=-2;
		j_x_boarder[6]=0;
		j_x_boarder[7]=2;
		j_x_boarder[8]=-1;
		j_x_boarder[9]=1;
		j_x_boarder[10]=1;
		j_x_boarder[11]=-1;
		Jx[s].resize(12);
		Jx[s] = std::valarray<int>(j_x_boarder,12);
		int j_x_corner[] = {0,-1,0,1,0,2,0,-1,1,1,-1};
		Jx[nw].resize(11);
		Jx[nw] = std::valarray<int>(j_x_corner,11);
		j_x_corner[5]=-2;
		j_x_corner[6]=0;
		j_x_boarder[7]=-1;
		j_x_boarder[8]=1;
		j_x_boarder[9]=1;
		j_x_boarder[10]=-1;
		Jx[ne].resize(11);
		Jx[ne] = std::valarray<int>(j_x_corner,11);
		j_x_corner[5]=-2;
		j_x_corner[6]=0;
		j_x_boarder[7]=-1;
		j_x_boarder[8]=1;
		j_x_boarder[9]=1;
		j_x_boarder[10]=-1;
		Jx[se].resize(11);
		Jx[se] = std::valarray<int>(j_x_corner,11);
		j_x_corner[5]=0;
		j_x_corner[6]=2;
		j_x_boarder[7]=-1;
		j_x_boarder[8]=1;
		j_x_boarder[9]=1;
		j_x_boarder[10]=-1;
		Jx[sw].resize(11);
		Jx[sw] = std::valarray<int>(j_x_corner,11);
		return Jx;
	}
	std::vector<std::valarray<int> > init_J_y()
	{
		std::vector<std::valarray<int> > Jy(13);
		const int j_y_c[] = {0,0,1,0,-1,0,2,0,-2,1,1,-1,-1};
		Jy[c].resize(13);
		Jy[c] = std::valarray<int>(j_y_c,13);
		int j_y_boarder[] = {0,0,1,0,-1,2,0,-2,1,1,-1,-1};
		Jy[w].resize(12);
		Jy[w] = std::valarray<int>(j_y_boarder,12);
		j_y_boarder[5]=j_y_boarder[6]=0;
		j_y_boarder[7]=-2;
		j_y_boarder[8]=1;
		j_y_boarder[9]=1;
		j_y_boarder[10]=-1;
		j_y_boarder[11]=-1;
		Jy[n].resize(12);
		Jy[n] = std::valarray<int>(j_y_boarder,12);
		j_y_boarder[5]=0;
		j_y_boarder[6]=2;
		j_y_boarder[7]=-2;
		j_y_boarder[8]=1;
		j_y_boarder[9]=1;
		j_y_boarder[10]=-1;
		j_y_boarder[11]=-1;
		Jy[e].resize(12);
		Jy[e] = std::valarray<int>(j_y_boarder,12);
		j_y_boarder[5]=0;
		j_y_boarder[6]=2;
		j_y_boarder[7]=0;
		j_y_boarder[8]=1;
		j_y_boarder[9]=1;
		j_y_boarder[10]=-1;
		j_y_boarder[11]=-1;
		Jy[s].resize(12);
		Jy[s] = std::valarray<int>(j_y_boarder,12);
		int j_y_corner[] = {0,0,1,0,-1,0,-2,1,1,-1,-1};
		Jy[nw].resize(11);
		Jy[nw] = std::valarray<int>(j_y_corner,11);
		j_y_corner[5]=0;
		j_y_corner[6]=-2;
		j_y_boarder[7]=1;
		j_y_boarder[8]=1;
		j_y_boarder[9]=-1;
		j_y_boarder[10]=-1;
		Jy[ne].resize(11);
		Jy[ne] = std::valarray<int>(j_y_corner,11);
		j_y_corner[5]=0;
		j_y_corner[6]=2;
		j_y_boarder[7]=1;
		j_y_boarder[8]=1;
		j_y_boarder[9]=-1;
		j_y_boarder[10]=-1;
		Jy[se].resize(11);
		Jy[se] = std::valarray<int>(j_y_corner,11);
		j_y_corner[5]=2;
		j_y_corner[6]=0;
		j_y_boarder[7]=1;
		j_y_boarder[8]=1;
		j_y_boarder[9]=-1;
		j_y_boarder[10]=-1;
		Jy[sw].resize(11);
		Jy[sw] = std::valarray<int>(j_y_corner,11);
		return Jy;
	}
	//we don't want these autogenerated contors and operators
	Biharmonic2D2(const Biharmonic2D2& rhs);
	Biharmonic2D2& operator=(const Biharmonic2D2& rhs);
public:
	/**
	 * \brief The constructor of a Biharmonic2D2 object
	 * 
	 * Biharmonic2D2 constructs a Biharmonic2D2 where \f$a_x\f$ and \f$a_y\f$
	 * are given by:
	 * \param[in] a_x	coefficient of the diff. operator (default 1.0)
	 * \param[in] a_y	coefficient of the diff. operator (default 1.0)
	 */
	explicit Biharmonic2D2()
			: L_c(13),L_boarder(12),L_corner(11),J_x(init_J_x()),J_y(init_J_y()) {}
	virtual ~Biharmonic2D2() {}
	inline Precision apply_c(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (6.0*Nx*Nx*Nx*Nx+6.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i-2]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i-1]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i+1]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i+2]
				+1.0*Ny*Ny*Ny*Ny*u[(j-2)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j-1)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j+1)*(Nx+1)+i]
				+1.0*Ny*Ny*Ny*Ny*u[(j+2)*(Nx+1)+i]
		        +2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i-1]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i-1];

	}
	inline Precision get_center_c(const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		return (6.0*Nx*Nx*Nx*Nx+6.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny);
	}
	inline Precision apply_w(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+6.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i-1]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i+1]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i+2]
				+1.0*Ny*Ny*Ny*Ny*u[(j-2)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j-1)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j+1)*(Nx+1)+i]
				+1.0*Ny*Ny*Ny*Ny*u[(j+2)*(Nx+1)+i]
		        +2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i-1]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i-1];
	}
	inline Precision get_center_w(const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+6.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny);
	}
	inline Precision apply_nw(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i-1]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i+1]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i+2]
				+1.0*Ny*Ny*Ny*Ny*u[(j-2)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j-1)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j+1)*(Nx+1)+i]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i-1]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i-1];
	}
	inline Precision apply_n(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (6.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i-2]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i-1]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i+1]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i+2]
				+1.0*Ny*Ny*Ny*Ny*u[(j-2)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j-1)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j+1)*(Nx+1)+i]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i-1]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i-1];
	}
	inline Precision apply_ne(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i-2]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i-1]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i+1]
				+1.0*Ny*Ny*Ny*Ny*u[(j-2)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j-1)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j+1)*(Nx+1)+i]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i-1]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i-1];
	}
	inline Precision apply_e(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+6.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i-2]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i-1]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i+1]
				+1.0*Ny*Ny*Ny*Ny*u[(j-2)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j-1)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j+1)*(Nx+1)+i]
				+1.0*Ny*Ny*Ny*Ny*u[(j+2)*(Nx+1)+i]
		        +2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i-1]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i-1];
	}
	inline Precision apply_se(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i-2]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i-1]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i+1]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j-1)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j+1)*(Nx+1)+i]
				+1.0*Ny*Ny*Ny*Ny*u[(j+2)*(Nx+1)+i]
		        +2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i-1]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i-1];
	}
	inline Precision apply_s(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (6.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i-2]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i-1]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i+1]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i+2]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j-1)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j+1)*(Nx+1)+i]
				+1.0*Ny*Ny*Ny*Ny*u[(j+2)*(Nx+1)+i]
		        +2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i-1]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i-1];
	}
	inline Precision apply_sw(const std::valarray<Precision>& u,
								const size_t i, const size_t j,
								const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i-1]
				-(4.0*Nx*Nx*Nx*Nx+4.0*Nx*Nx*Ny*Ny)*u[j*(Nx+1)+i+1]
				+1.0*Nx*Nx*Nx*Nx*u[j*(Nx+1)+i+2]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j-1)*(Nx+1)+i]
				-(4.0*Ny*Ny*Ny*Ny+4.0*Nx*Nx*Ny*Ny)*u[(j+1)*(Nx+1)+i]
				+1.0*Ny*Ny*Ny*Ny*u[(j+2)*(Nx+1)+i]
		        +2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i-1]
				+2.0*Nx*Nx*Ny*Ny*u[(j+1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i+1]
				+2.0*Nx*Nx*Ny*Ny*u[(j-1)*(Nx+1)+i-1];
	}
	inline Precision get_center_nw(const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny);	
	}
	inline Precision get_center_n(const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		return (6.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny);	
	}
	inline Precision get_center_ne(const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny);	
	}
	inline Precision get_center_e(const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+6.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny);	
	}
	inline Precision get_center_se(const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny);	
	}
	inline Precision get_center_s(const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		return (6.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny);	
	}
	inline Precision get_center_sw(const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		return (7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny);	
	}
	/**
	 * \brief retruns the coefficents of Biharmonic2D2 for a center point.
	 * 
	 * get_L_c() returns the coefficients of Biharmonic2D2 as valarray. For the
	 * ordering of the elements
	 * \see Stencil
	 * E.g. Biharmonic2D2 with the stepsize hx=hy=1 at a center point
	 * looks like:
	 * \f[
	 * \frac{1}{12}
	 * \left[\begin{array}{ccccc}
	 * 	&	&		1	&	&	\\
	 * 	&	2&		-8	2&	&	\\
	 *  1&	-8&	20&	-8&	1\\
	 * 	&	2&		-8	2&	&	\\
	 * &	&		1	&	&	\\
	 * \end{array}\right]
	 * \f]
	 * So we have:\n
	 * L	= {20,-8,-8,-8,-8, 1, 1, 1, 1, 2, 2, 2, 2}\n
	 * J_x 	= { 0,-1,0,1,0,-2,0,2,0,-1,1,1,-1}\n
	 * J_y 	= { 0,0,1,0,-1,0,2,0,-2,1,1,-1,-1}\n
	 * 
	 * \param[in]		the x coordinate of the center element (not used)
	 * \param[in]		the y coordinate of the center element (not used)
	 * \param[in] Nx	the step size in x direction
	 * \param[in] Ny	the step size in y direction
	 * \return			the coefficients of Biharmonic2D4
	 */
	inline const std::valarray<Precision>& get_L_c(
							const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		L_c[0] = 6.0*Nx*Nx*Nx*Nx+6.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny;
		L_c[1] = L_c[3] = -4.0*Nx*Nx*Nx*Nx-4.0*Nx*Nx*Ny*Ny;
		L_c[5] = L_c[7] = +1.0*Nx*Nx*Nx*Nx;
		L_c[2] = L_c[4] = -4.0*Ny*Ny*Ny*Ny-4.0*Nx*Nx*Ny*Ny;
		L_c[6] = L_c[8] = +1.0*Ny*Ny*Ny*Ny;
		L_c[9] = L_c[10] = L_c[11] = L_c[12] = +2.0*Nx*Nx*Ny*Ny;
		return L_c;
	}
	inline const std::valarray<Precision>& get_L_w(
							const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		L_boarder[0] = 7.0*Nx*Nx*Nx*Nx+6.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny;
		L_boarder[1] = L_boarder[3] = -4.0*Nx*Nx*Nx*Nx-4.0*Nx*Nx*Ny*Ny;
		L_boarder[2] = L_boarder[4] = -4.0*Ny*Ny*Ny*Ny-4.0*Nx*Nx*Ny*Ny;
		L_boarder[5] = L_boarder[7] = +1.0*Ny*Ny*Ny*Ny;
		L_boarder[6] = +1.0*Nx*Nx*Nx*Nx;
		L_boarder[8] = L_boarder[9] = +2.0*Nx*Nx*Ny*Ny;
		L_boarder[10] = L_boarder[11] = +2.0*Nx*Nx*Ny*Ny;
		return L_boarder;
	}
	inline const std::valarray<Precision>& get_L_nw(
							const size_t, const size_t,
							const size_t Nx, const size_t Ny) const
	{
		L_corner[0] = 7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny;
		L_corner[1] = L_corner[3] = -4.0*Nx*Nx*Nx*Nx-4.0*Nx*Nx*Ny*Ny;
		L_corner[2] = L_corner[4] = -4.0*Ny*Ny*Ny*Ny-4.0*Nx*Nx*Ny*Ny;
		L_corner[5] = +1.0*Nx*Nx*Nx*Nx;
		L_corner[6] = +1.0*Ny*Ny*Ny*Ny;
		L_corner[7] = L_corner[8] = +2.0*Nx*Nx*Ny*Ny;
		L_corner[9] = L_corner[10] = +2.0*Nx*Nx*Ny*Ny;
		return L_corner;
	}
	inline const std::valarray<Precision>& get_L_n(
							const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		L_boarder[0] = 6.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny;
		L_boarder[1] = L_boarder[3] = -4.0*Nx*Nx*Nx*Nx-4.0*Nx*Nx*Ny*Ny;
		L_boarder[2] = L_boarder[4] = -4.0*Ny*Ny*Ny*Ny-4.0*Nx*Nx*Ny*Ny;
		L_boarder[5] = L_boarder[6] = +1.0*Nx*Nx*Nx*Nx;
		L_boarder[7] = +1.0*Ny*Ny*Ny*Ny;
		L_boarder[8] = L_boarder[9] = +2.0*Nx*Nx*Ny*Ny;
		L_boarder[10] = L_boarder[11] = +2.0*Nx*Nx*Ny*Ny;
		return L_boarder;
	}
	inline const std::valarray<Precision>& get_L_ne(
							const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		L_corner[0] = 7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny;
		L_corner[1] = L_corner[3] = -4.0*Nx*Nx*Nx*Nx-4.0*Nx*Nx*Ny*Ny;
		L_corner[2] = L_corner[4] = -4.0*Ny*Ny*Ny*Ny-4.0*Nx*Nx*Ny*Ny;
		L_corner[5] = +1.0*Nx*Nx*Nx*Nx;
		L_corner[6] = +1.0*Ny*Ny*Ny*Ny;
		L_corner[7] = L_corner[8] = +2.0*Nx*Nx*Ny*Ny;
		L_corner[9] = L_corner[10] = +2.0*Nx*Nx*Ny*Ny;
		return L_corner;
	}
	inline const std::valarray<Precision>& get_L_e(
							const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		L_boarder[0] = 7.0*Nx*Nx*Nx*Nx+6.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny;
		L_boarder[1] = L_boarder[3] = -4.0*Nx*Nx*Nx*Nx-4.0*Nx*Nx*Ny*Ny;
		L_boarder[2] = L_boarder[4] = -4.0*Ny*Ny*Ny*Ny-4.0*Nx*Nx*Ny*Ny;
		L_boarder[6] = L_boarder[7] = +1.0*Ny*Ny*Ny*Ny;
		L_boarder[5] = +1.0*Nx*Nx*Nx*Nx;
		L_boarder[8] = L_boarder[9] = +2.0*Nx*Nx*Ny*Ny;
		L_boarder[10] = L_boarder[11] = +2.0*Nx*Nx*Ny*Ny;
		return L_boarder;
	}
	inline const std::valarray<Precision>& get_L_se(
							const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		L_corner[0] = 7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny;
		L_corner[1] = L_corner[3] = -4.0*Nx*Nx*Nx*Nx-4.0*Nx*Nx*Ny*Ny;
		L_corner[2] = L_corner[4] = -4.0*Ny*Ny*Ny*Ny-4.0*Nx*Nx*Ny*Ny;
		L_corner[5] = +1.0*Nx*Nx*Nx*Nx;
		L_corner[6] = +1.0*Ny*Ny*Ny*Ny;
		L_corner[7] = L_corner[8] = +2.0*Nx*Nx*Ny*Ny;
		L_corner[9] = L_corner[10] = +2.0*Nx*Nx*Ny*Ny;
		return L_corner;
	}
	inline const std::valarray<Precision>& get_L_s(
							const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		L_boarder[0] = 7.0*Nx*Nx*Nx*Nx+6.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny;
		L_boarder[1] = L_boarder[3] = -4.0*Nx*Nx*Nx*Nx-4.0*Nx*Nx*Ny*Ny;
		L_boarder[2] = L_boarder[4] = -4.0*Ny*Ny*Ny*Ny-4.0*Nx*Nx*Ny*Ny;
		L_boarder[5] = L_boarder[7] = +1.0*Nx*Nx*Nx*Nx;
		L_boarder[6] = +1.0*Ny*Ny*Ny*Ny;
		L_boarder[8] = L_boarder[9] = +2.0*Nx*Nx*Ny*Ny;
		L_boarder[10] = L_boarder[11] = +2.0*Nx*Nx*Ny*Ny;
		return L_boarder;
	}
	inline const std::valarray<Precision>& get_L_sw(
							const size_t , const size_t ,
							const size_t Nx, const size_t Ny) const
	{
		L_corner[0] = 7.0*Nx*Nx*Nx*Nx+7.0*Ny*Ny*Ny*Ny+8.0*Nx*Nx*Ny*Ny;
		L_corner[1] = L_corner[3] = -4.0*Nx*Nx*Nx*Nx-4.0*Nx*Nx*Ny*Ny;
		L_corner[2] = L_corner[4] = -4.0*Ny*Ny*Ny*Ny-4.0*Nx*Nx*Ny*Ny;
		L_corner[6] = +1.0*Nx*Nx*Nx*Nx;
		L_corner[5] = +1.0*Ny*Ny*Ny*Ny;
		L_corner[7] = L_corner[8] = +2.0*Nx*Nx*Ny*Ny;
		L_corner[9] = L_corner[10] = +2.0*Nx*Nx*Ny*Ny;
		return L_corner;
	}
	inline const std::valarray<int>& get_J_x(const Position p =c) const
	{
		return J_x[p];
	}
	inline const std::valarray<int>& get_J_y(const Position p =c) const
	{
		return J_y[p];
	}
	/**
	 * \brief does nothing for Biharmonic2D2
	 * \see Stencil
	 */
	void push_prolongation(const Prolongation&) {}
	/**
	 * \brief does nothing for Biharmonic2D2
	 * \see Stencil
	 */
	void pop_prolongation() {}
	/**
	 * \brief does nothing for Biharmonic2D2
	 * \see Stencil
	 */
	void push_restriction(const Restriction&) {}
	/**
	 * \brief does nothing for Biharmonic2D2
	 * \see Stencil
	 */
	void pop_restriction() {}
	/**
	 * \brief gives the max expansion of Biharmonic2D2
	 * 
	 * \return	2
	 */
	inline size_t size() const
	{
		return 2;
	}
	/**
	 * \brief returns true, because Biharmonic2D2 is constant
	 * 
	 * \return	true
	 */
	inline bool is_constant() const
	{
		return true;
	}
};

}

#endif /*Biharmonic2D2_H_*/
