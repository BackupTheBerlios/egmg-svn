/** \file DeZeeuw_interpolation.h
 * \author Benedikt Engbroks
 * \brief Contains the interface of the class DeZeeuw_interpolation
 * 
 * This file contains the interface of DeZeeuw_interpolation. The
 * implementation is in DeZeeuw_interpolation.cpp
 */
#ifndef DEZEEUW_INTERPOLATION_H_
#define DEZEEUW_INTERPOLATION_H_

#include "Prolongation.h"
#include "../Stencil/Stencil.h"

namespace mg
{

/**
 * \brief DeZeeuw_interpolation is a matrix-dependent 2D Prolongation Operator
 * 
 * DeZeeuw_interpolation represents a 2D Prolongation Operator that uses
 * matrix-dependent interpolation by De Zeeuw to do its job.
 */
class DeZeeuw_interpolation : public mg::Prolongation
{
private:
	std::valarray<precision> t;
	const std::valarray<int> J_x;
	const std::valarray<int> J_y;
	//initialize J_x, makes it possible to make J_x const
	std::valarray<int> init_J_x() const
	{
		const int t[] = {0,-1,0,1,0,-1,1,1,-1};
		return std::valarray<int>(t,9);
	}
	//initialize J_y, makes it possible to make J_y const
	std::valarray<int> init_J_y() const
	{
		const int t[] = {0,0,1,0,-1,1,1,-1,-1};
		return std::valarray<int>(t,9);
	}
	//we don't want these autogenerated contrs and operators
	DeZeeuw_interpolation(const DeZeeuw_interpolation& rhs);
	DeZeeuw_interpolation& operator=(const DeZeeuw_interpolation& rhs);
	
	static const int SW = 0;
	static const int S = 1;
	static const int SE = 2;
	static const int W = 3;
	static const int C = 4;
	static const int E = 5;
	static const int NW = 6;
	static const int N = 7;
	static const int NE = 8;
public:
	DeZeeuw_interpolation() : t(9), J_x(init_J_x()), J_y(init_J_y()) {}
	virtual ~DeZeeuw_interpolation() {}
	/**
	 * \brief prolong does a matrix-dependent interpolation on the input vector
	 * 
	 * \param u		the vector representing a rectangle to prolongate
	 * \param Nx	Number of steps in x direction
	 * \param Ny	Number of steps in y direction
	 * \return 		a vector representing the prolongated rectangle of 
	 * 				size 2*(Nx+1)*2*(Ny+1)
	 */
	std::valarray<precision> prolong(const std::valarray<precision>& u, const Stencil& stencil, 
									const size_t Nx,const size_t Ny) const;

	const std::valarray<precision>& get_I(const size_t i, const size_t j, 
		const size_t Nx, const size_t Ny, const Stencil& stencil)
	{
		std::valarray<precision> L = stencil.get_L_c(0,0,Nx,Ny);
		std::valarray<int> J_x = stencil.get_J_x(c);
		std::valarray<int> J_y = stencil.get_J_y(c);
		std::valarray<size_t> posi(9);
		for (size_t jj=0;jj<J_x.size();jj++)
		{
			posi[(J_x[jj]+1)+3*(J_y[jj]+1)] = jj;
		}
		std::valarray<precision> mS(9);
		std::valarray<precision> mT(9);

		precision scale = 0;
		precision weight1 = 0;
		precision weight2 = 0;
		precision erg = 0;
		precision symsum;
		precision d_w;
		precision d_e;
		precision d_n;
		precision d_s;
		precision sigma1;
		precision c_1;
		precision w_w;
		precision w_e;
		precision sigma2;
		precision c_2;
		precision w_s;
		precision w_n;

		// C
		t[0] = 1.0;
		// W
			L = stencil.get_L_c(i-1,j,Nx,Ny);
			symsum = 0;
			
			// Divide the stencil defined by L und posi into a symmetric and an antisymmetric part.
			for (size_t k=0; k<9; k++)
			{
				mS[k] = 0.5*(L[posi[k]] + L[posi[8-k]]);
				symsum += mS[k];
				mT[k] = 0.5*(L[posi[k]] - L[posi[8-k]]);
			}
			d_w = std::max(std::fabs(mS[SW] + mS[W] + mS[NW]), std::max(std::fabs(mS[SW]), std::fabs(mS[NW])));
			d_e = std::max(std::fabs(mS[SE] + mS[E] + mS[NE]), std::max(std::fabs(mS[SE]), std::fabs(mS[NE])));
			d_n = std::max(std::fabs(mS[NW] + mS[N] + mS[NE]), std::max(std::fabs(mS[NW]), std::fabs(mS[NE])));
			d_s = std::max(std::fabs(mS[SW] + mS[S] + mS[SE]), std::max(std::fabs(mS[SW]), std::fabs(mS[SE])));
			sigma1 = 0.5 * std::min(1.0, std::fabs(1 - symsum/L[0]));
			c_1 = mT[SE] + mT[E] + mT[NE] - mT[SW] - mT[W] - mT[NW];
			w_w = sigma1 * (1 + (d_w-d_e)/(d_w+d_e) + c_1 / (d_w+d_e+d_n+d_s));
			w_e = 2*sigma1-w_w;
			weight2 = std::min(2*sigma1, std::max(w_e, 0.0));
			t[1] = weight2; 
		// N
			L = stencil.get_L_c(i,j+1,Nx,Ny);
			symsum = 0;
			
			// Divide the stencil defined by L und posi into a symmetric and an antisymmetric part.
			for (int k=0; k<9; k++)
			{
				mS[k] = 0.5*(L[posi[k]] + L[posi[8-k]]);
				symsum += mS[k];
				mT[k] = 0.5*(L[posi[k]] - L[posi[8-k]]);
			}
			d_w = std::max(std::fabs(mS[SW] + mS[W] + mS[NW]), std::max(std::fabs(mS[SW]), std::fabs(mS[NW])));
			d_e = std::max(std::fabs(mS[SE] + mS[E] + mS[NE]), std::max(std::fabs(mS[SE]), std::fabs(mS[NE])));
			d_n = std::max(std::fabs(mS[NW] + mS[N] + mS[NE]), std::max(std::fabs(mS[NW]), std::fabs(mS[NE])));
			d_s = std::max(std::fabs(mS[SW] + mS[S] + mS[SE]), std::max(std::fabs(mS[SW]), std::fabs(mS[SE])));
			sigma2 = 0.5 * std::min(1.0, std::fabs(1 - symsum/L[0]));
			c_2 = mT[NW] + mT[N] + mT[NE] - mT[SW] - mT[S] - mT[SE];
			w_n = sigma2 * (1 + (d_s-d_n)/(d_s+d_n) + c_2 / (d_w+d_e+d_n+d_s));
			w_s = 2*sigma2-w_n;
			weight1 = std::min(2*sigma2, std::max(w_s, 0.0));
			weight2 = std::min(2*sigma2, std::max(w_n, 0.0));
			t[2] = weight1;
		// E
			L = stencil.get_L_c(i+1,j,Nx,Ny);
			symsum = 0;
			
			// Divide the stencil defined by L und posi into a symmetric and an antisymmetric part.
			for (size_t k=0; k<9; k++)
			{
				mS[k] = 0.5*(L[posi[k]] + L[posi[8-k]]);
				symsum += mS[k];
				mT[k] = 0.5*(L[posi[k]] - L[posi[8-k]]);
			}
			d_w = std::max(std::fabs(mS[SW] + mS[W] + mS[NW]), std::max(std::fabs(mS[SW]), std::fabs(mS[NW])));
			d_e = std::max(std::fabs(mS[SE] + mS[E] + mS[NE]), std::max(std::fabs(mS[SE]), std::fabs(mS[NE])));
			d_n = std::max(std::fabs(mS[NW] + mS[N] + mS[NE]), std::max(std::fabs(mS[NW]), std::fabs(mS[NE])));
			d_s = std::max(std::fabs(mS[SW] + mS[S] + mS[SE]), std::max(std::fabs(mS[SW]), std::fabs(mS[SE])));
			sigma1 = 0.5 * std::min(1.0, std::fabs(1 - symsum/L[0]));
			c_1 = mT[SE] + mT[E] + mT[NE] - mT[SW] - mT[W] - mT[NW];
			w_w = sigma1 * (1 + (d_w-d_e)/(d_w+d_e) + c_1 / (d_w+d_e+d_n+d_s));
			w_e = 2*sigma1-w_w;
			weight1 = std::min(2*sigma1, std::max(w_w, 0.0));
			t[3] = weight1; 
		// S
			L = stencil.get_L_c(i,j-1,Nx,Ny);
			symsum = 0;
			
			// Divide the stencil defined by L und posi into a symmetric and an antisymmetric part.
			for (int k=0; k<9; k++)
			{
				mS[k] = 0.5*(L[posi[k]] + L[posi[8-k]]);
				symsum += mS[k];
				mT[k] = 0.5*(L[posi[k]] - L[posi[8-k]]);
			}
			d_w = std::max(std::fabs(mS[SW] + mS[W] + mS[NW]), std::max(std::fabs(mS[SW]), std::fabs(mS[NW])));
			d_e = std::max(std::fabs(mS[SE] + mS[E] + mS[NE]), std::max(std::fabs(mS[SE]), std::fabs(mS[NE])));
			d_n = std::max(std::fabs(mS[NW] + mS[N] + mS[NE]), std::max(std::fabs(mS[NW]), std::fabs(mS[NE])));
			d_s = std::max(std::fabs(mS[SW] + mS[S] + mS[SE]), std::max(std::fabs(mS[SW]), std::fabs(mS[SE])));
			sigma2 = 0.5 * std::min(1.0, std::fabs(1 - symsum/L[0]));
			c_2 = mT[NW] + mT[N] + mT[NE] - mT[SW] - mT[S] - mT[SE];
			w_n = sigma2 * (1 + (d_s-d_n)/(d_s+d_n) + c_2 / (d_w+d_e+d_n+d_s));
			w_s = 2*sigma2-w_n;
			weight2 = std::min(2*sigma2, std::max(w_n, 0.0));
			t[4] = weight2;
		// NW
			L = stencil.get_L_c(i-1,j+1,Nx,Ny);
			scale = -L[0];
			erg = 0;
			if (posi[E] != 0) erg += L[posi[E]] * t[2];
			if (posi[S] != 0) erg += L[posi[S]] * t[1];
			if (posi[SE] != 0) erg += L[posi[SE]];
			t[5] = erg / scale;
		// NE
			L = stencil.get_L_c(i+1,j+1,Nx,Ny);
			scale = -L[0];
			erg = 0;
			if (posi[W] != 0) erg += L[posi[W]] * t[2];
			if (posi[S] != 0) erg += L[posi[S]] * t[3];
			if (posi[SW] != 0) erg += L[posi[SW]];
			t[6] = erg / scale;
		// SE
			L = stencil.get_L_c(i+1,j-1,Nx,Ny);
			scale = -L[0];
			erg = 0;
			if (posi[W] != 0) erg += L[posi[W]] * t[4];
			if (posi[N] != 0) erg += L[posi[N]] * t[3];
			if (posi[NW] != 0) erg += L[posi[NW]];
			t[7] = erg / scale;
		// SW
			L = stencil.get_L_c(i-1,j-1,Nx,Ny);
			scale = -L[0];
			erg = 0;
			if (posi[E] != 0) erg += L[posi[E]] * t[4];
			if (posi[N] != 0) erg += L[posi[N]] * t[1];
			if (posi[NE] != 0) erg += L[posi[NE]];
			t[8] = erg / scale;
		return t;	
	}
	const std::valarray<int>& get_J_x() const
	{
		return J_x;	
	}
	const std::valarray<int>& get_J_y() const
	{
		return J_y;
	}
	
};

}

#endif /*DEZEEUW_INTERPOLATION_H_*/
