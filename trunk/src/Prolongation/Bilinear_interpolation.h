/** \file Bilinear_interpolation.h
 * \author <a href="mailto:mail@jirikraus.de">Jiri Kraus</a>
 * \brief Contains the interface of the class Bilinear_interpolation
 */
#ifndef BILINEAR_INTERPOLATION_H_
#define BILINEAR_INTERPOLATION_H_

#include "Prolongation.h"

namespace mg
{

/**
 * \brief Bilinear_interpolation is a 2D Prolongation Operator
 * 
 * Bilinear_interpolation represents a 2D Prolongation Operator that uses
 * bilinear interpolation to do its job.
 */
class Bilinear_interpolation : public mg::Prolongation
{
private:
	const std::valarray<Precision> I;
	const std::valarray<int> J_x;
	const std::valarray<int> J_y;
	//initialize I, makes it possible to make I const
	std::valarray<Precision> init_I() const
	{
		const Precision t[] = {1.0,1.0/2,1.0/2,1.0/2,1.0/2,1.0/4,1.0/4,1.0/4,1.0/4};
		return std::valarray<Precision>(t,9);
	}
	//initialize J_x, makes it possible to make J_x const
	std::valarray<int> init_J_x() const
	{
		const int t[] = {0,-1,0,1,0,-1,1,1,-1};
		return std::valarray<int>(t,9);
	}
	//initialize J_y, makes it possible to make J_y const
	std::valarray<int> init_J_y() const
	{
		const int t[] = {0,0,1,0,-1,1,1,-1,-1};
		return std::valarray<int>(t,9);
	}
	//we don't want these autogenerated contrs and operators
	Bilinear_interpolation(const Bilinear_interpolation& rhs);
	Bilinear_interpolation& operator=(const Bilinear_interpolation& rhs);
public:
	Bilinear_interpolation()
		: I(init_I()), J_x(init_J_x()), J_y(init_J_y()) {}
	virtual ~Bilinear_interpolation() {}
	/**
	 * \brief prolongate does a bilinear interpolation on the input vector
	 * 
	 * \param[in] u			the vector representing a rectangel to prolongate
	 * \param[in] stencil	the stencil rep. of the pde needed for matrix dep.
	 * 						Prolongations (not used for Bilinear int.).
	 * \param[in] Nx		Number of steps in x direction
	 * \param[in] Ny		Number of steps in y direction
	 * \return 				a vector representing the prolongated rectangel of 
	 * 						size 2*(Nx+1)*2*(Ny+1)
	 */
	std::valarray<Precision> prolong(const std::valarray<Precision>& u,
									const Stencil& stencil,
									const size_t Nx,const size_t Ny) const;
	const std::valarray<Precision>& get_I(const size_t, const size_t,
									const size_t, const size_t, const Stencil&) const
	{
		return I;	
	}
	const std::valarray<int>& get_J_x() const
	{
		return J_x;	
	}
	const std::valarray<int>& get_J_y() const
	{
		return J_y;
	}
};

}

#endif /*BILINEAR_INTERPOLATION_H_*/
