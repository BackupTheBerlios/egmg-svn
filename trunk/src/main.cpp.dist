#include<valarray>
#include<vector>
#include<cmath>
#include<iostream>
#include "./Stencil/StencilIncludes.h"
#include "./Restriction/RestricionIncludes.h"
#include "./Relaxation/RelaxationIncludes.h"
#include "./Prolongation/ProlongationIncludes.h"
#include "./functions/functionsIncludes.h"
#include "./CycleTypeIncludes.h"
#include "./general/parameters.h"

using namespace mg;

int main()
{
	const int k = 8;
	const size_t Nx =static_cast<size_t>(std::pow(2.,k));
	const size_t Ny = Nx;
	std::valarray<precision> u(1000.0,(Nx+1)*(Ny+1));
	std::valarray<precision> fv(0.0,(Nx+1)*(Ny+1));
	putbval(u,Nx,Ny,zero);
	putrhs(fv,Nx,Ny,zero);
	const size_t itmax = 100;
	size_t iterations = 0;
	const precision eps = 1e-30;
	std::cout<<"Genauigkeit : "<<eps<<std::endl;
	Laplacian2D4 lap;
	lineGS relaxation(1,1,altline);
	precision resnull = twonorm_residuum(u,fv,lap,Nx,Ny);
	precision resnew = resnull;
	precision resold = resnull;
	Full_Weighting restriction;
	Bilinear_interpolation prolongation;
	//residues is used to store the intermediate residues, there are printed
	//after the cycle iterations because writing to std out takes a long time
	std::vector<precision> residues;
	residues.push_back(resnull);
	while ((iterations < itmax) && (resnew/resnull > eps))
	{
		resold=resnew;
		cycle(u,fv,lap,prolongation,restriction,relaxation,Nx,Ny,1,1);
		//cycle(u,fv,lap,prolongation,restriction,relaxation,Nx,Ny);
		resnew=twonorm_residuum(u,fv,lap,Nx,Ny);
		residues.push_back(resnew);
		std::cout<<resnew<<std::endl;
		if ((resnew > resold) && (iterations > 3))
		{
			std::cout<<"No convergence"<<std::endl;
			break;	
		}
		iterations++;
	}
	//print out the defects history
	output(residues,1);
	std::cout<<"fehler = "<<error(u,Nx,Ny,zero)<<" it = "<<iterations<<std::endl;
	return 0;
}
