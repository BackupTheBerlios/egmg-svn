/** \file Half_Weighting.h
 * \author Mareike Riepl, Michaela Anghel, Daniela Steffes-Lai
 * \brief Contains the interface of the class Half Weighting
 */
#ifndef HALF_WEIGHTING_H_
#define HALF_WEIGHTING_H_

#include "Restriction.h"

namespace mg
{

/**
 * \brief Half_Weighting is a 2D restriction operator
 * 
 * Half_Weighting is a representation of a 2D restriction operator that uses
 * half weighting to do its job.
 */
class Half_Weighting : public mg::Restriction
{
private:
	const Precision weight_;
	const NumericArray I;
	const PositionArray J_x;
	const PositionArray J_y;
	//initilize I, makes it possible to make I const
	NumericArray init_I(Precision weight) const
	{
		const Precision t[] = {weight/4,weight/8,weight/8,weight/8,weight/8,
									0,0,0,0};
		return NumericArray(t,9);
	}
	//initilize J_x, makes it possible to make J_x const
	PositionArray init_J_x() const
	{
		const int t[] = {0,-1,0,1,0,-1,1,1,-1};
		return PositionArray(t,9);
	}
	//initilize J_y, makes it possible to make J_y const
	PositionArray init_J_y() const
	{
		const int t[] = {0,0,1,0,-1,1,1,-1,-1};
		return PositionArray(t,9);
	}
	//we don't want these autogenerated contors and operators
	Half_Weighting(const Half_Weighting& rhs);
	Half_Weighting& operator=(const Half_Weighting& rhs);
public:
	/**
	 * \brief The constructor of a Half_Weighting object
	 * 
	 * Half_Weighting constructs a Half_Weighting object with:
	 * \param[in] weight	the weight to do half weighting with (default 1.0)
	 */
	Half_Weighting(Precision weight = 1.0)
		: weight_(weight),I(init_I(weight)), J_x(init_J_x()), J_y(init_J_y()) {}
	virtual ~Half_Weighting(){}
	/**
	 * \brief restriction() restricts the given vector to a smaller grid
	 * 
	 * restriction() restricts the given vector which represents a rectangular
	 * grid to a smaller grid with the double step size with the half weighting
	 * Operator.
	 * 
	 * \param[in] u					the vector to restrict
	 * \param[in] stencil			the stencil rep. of the pde needed
	 * 								for matrix dep. Restrictions (not used)
	 * \param[in] prolongate			Prolongation used, needed for matrix dep.
	 * 								Restrictions (not used)
	 * \param[in] Nx				number of steps in x direction
	 * \param[in] Ny				number of steps in y direction
	 * \throw std::domain_error		if Nx or Ny is not divedable by 2
	 * \return						a vector with the values on the restricted
	 * 								grid
	 */
	NumericArray restriction(const NumericArray& u,
					const Stencil& stencil,
					const Prolongation& prolong,
					const size_t Nx, const size_t Ny) const;
	const NumericArray& get_I(const size_t, const size_t,
									const size_t, const size_t, const Stencil&) const
	{
		return I;	
	}
	const PositionArray& get_J_x() const
	{
		return J_x;	
	}
	const PositionArray& get_J_y() const
	{
		return J_y;
	}
};

}

#endif /*HALF_WEIGHTING_H_*/
